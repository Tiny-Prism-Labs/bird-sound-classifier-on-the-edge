<!DOCTYPE html>
<html>
 <head>
  <title>Web BLE Activity Tracking</title>
  <link
   href="https://fonts.googleapis.com/css?family=Roboto&display=swap"
   rel="stylesheet"
  />
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@jaames/iro/dist/iro.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/109/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/json-to-csv-export"></script>

  <!-- <script src="GLTFLoader.js"></script> -->
  <style>
   body {
    font-family: "Roboto", sans-serif;
    color: #fff5f5;
    background: #000000;
    font-size: small;
   }

   #bigButton {
    background-color: aqua;
    border: none;
    color: black;
    padding: 1px;
    text-align: center;
    text-decoration: none;
    font-size: 6px;
    margin: 12px 20px;
    height: 15px;
    width: 30px;
    border-radius: 10%;
    outline: none;
    font-family: "Roboto", sans-serif;
   }

   .container {
    width: 960px;
    height: 384px;
    margin-top: 30px;
    margin-bottom: 7.5px;
    margin: 0 auto;
   }

   .widget {
    background: #111111;
    border: 1px solid #000000;
    border-radius: 0px;
    padding: 12px;
    margin: 6px;
    float: left;
   }

   .status {
    background-image: url("logo.png");
    background-size: 80px;
    background-position: 98% 50%;
    background-repeat: no-repeat;
    width: 885px;
    height: 42px;
    color: white;
   }

   .square {
    width: 192px;
    height: 192px;
    position: relative;
   }

   .label {
    height: 15px;
    display: inline;
    font-size: 15px;
   }

   .digit {
    font-size: 30px;
    color: #888888;
    float: right;
   }

   .short {
    width: 192px;
    height: 96px;
   }
   .double {
    width: 900px;
    height: 225px;
   }
   .graph {
    width: 192px;
    height: 177px;
   }
   .doublegraph {
    width: 900px;
    height: 225px;
   }
   .shortgraph {
    width: 192px;
    height: 81px;
   }

   #color-picker-container {
    display: flex;
    align-items: center;
    justify-content: center;
   }

   .start {
    background-color: #021bd6;
    color: white;
    font-size: medium;
    height: 30px;
    width: 150px;
    position: relative;
    margin: 10px;
   }
   .center {
    justify-content: center;
    display: flex;
    align-items: center;
   }
   .download {
    background-color: #03be22;
    color: white;
    font-size: medium;
    height: 30px;
    width: 150px;
    position: relative;
    margin: 10px;
   }
   .stop {
    background-color: #e20909;
    color: white;
    font-size: medium;
    height: 30px;
    width: 150px;
    position: relative;
    margin: 10px;
   }
   .stopwatch {
    font-size: xx-large;
    position: relative;
   }

   transition {
    -webkit-transition: all 0.5s ease-in-out;
    -moz-transition: all 0.5s ease-in-out;
    transition: all 0.5s ease-in-out;
   }

   #seconds,
   #tens {
    font-size: 2em;
   }
  </style>
 </head>
 <body>
  <div class="container">
   <!-- <div class="label">&nbsp;&nbsp;IMPORTANT - first upload <a href="https://create.arduino.cc/editor/dpajak/e4128780-d76d-438f-97a4-541740cb0473/preview">sketch</a> to Arduino Nano 33 BLE Sense board<br></div> -->
   <div class="status widget">
    <button id="bigButton"></button>
    <div class="label" id="bluetooth">Click button to connect to the board</div>
   </div>

   <!-- <div class="square widget" id="3d">
      <div class="label">&#128230;3D</div>
    </div> -->

   <div class="double widget">
    <div class="label">&#128640; Accelerometer</div>
    <div id="accelerometer" class="doublegraph"></div>
   </div>

   <div class="double widget">
    <div class="label">&#128171; Gyroscope</div>
    <div id="gyroscope" class="doublegraph"></div>
   </div>

   <!-- <div class=" graph center">
    <h2>Stopwatch</h2>
   </div> -->

   <div class="doublegraph center">
    <div>
     <h2>Stopwatch</h2>
    </div>
    &nbsp; &nbsp; &nbsp;
    <div>
     <p class="stopwatch">
      <span id="seconds">00</span>:<span id="tens">00</span>
     </p>
    </div>
   </div>
   <div class="doublegraph center">
    <!-- <input class="label" type="text"> -->
    <button class="start" onclick="start_recording()">Start Recording</button>
    <button class="stop" onclick="stop_recording()">Stop Recording</button>
    <button class="download" onclick="download()">Download</button>
   </div>
  </div>
 </body>
 <script type="text/javascript">
  /*
Demo showing simple dashboard of Arduino BLE sense

Based on: https://developers.google.com/web/updates/2015/07/interact-with-ble-devices-on-the-web
For earlier versions of Windows and Linux, you still have to go to chrome://flags/#enable-experimental-web-platform-features,
enable the highlighted flag, and restart Chrome for now.
*/

  var seconds = 0;
  var tens = 0;
  var appendTens = document.getElementById("tens");
  var appendSeconds = document.getElementById("seconds");
  var buttonStart = document.getElementById("button-start");
  var buttonStop = document.getElementById("button-stop");
  var buttonReset = document.getElementById("button-reset");
  var Interval;

  var maxRecords = 64;

  var BLEsense = {
   accelerometer: {
    uuid: "6fbe1da7-3001-44de-92c4-bb6e04fb0212",
    properties: ["BLENotify"],
    structure: ["Float32", "Float32", "Float32"],
    data: { Ax: [], Ay: [], Az: [] },
   },
   gyroscope: {
    uuid: "6fbe1da7-3002-44de-92c4-bb6e04fb0212",
    properties: ["BLENotify"],
    structure: ["Float32", "Float32", "Float32"],
    data: { Gx: [], Gy: [], Gz: [] },
   },
  };

  // UPDATED: Data structure for recording now includes gyroscope fields
  var record_data = {
   timestamp: [],
   aX: [],
   aY: [],
   aZ: [],
   gX: [],
   gY: [],
   gZ: [],
  };

  const sensors = Object.keys(BLEsense);
  const SERVICE_UUID = "6fbe1da7-0000-44de-92c4-bb6e04fb0212";
  var bytesReceived = 0;
  var bytesPrevious = 0;

  // UI elements
  const bigButton = document.getElementById("bigButton");
  const BLEstatus = document.getElementById("bluetooth");

  if ("bluetooth" in navigator) {
   bigButton.addEventListener("click", function (event) {
    connect();
   });
  } else {
   msg("browser not supported");
   bigButton.style.backgroundColor = "red";
   alert(
    "Error: This browser doesn't support Web Bluetooth. Try using Chrome."
   );
  }

  function msg(m) {
   BLEstatus.innerHTML = m;
  }

  async function connect() {
   bigButton.style.backgroundColor = "grey";
   msg("requesting device ...");

   const device = await navigator.bluetooth.requestDevice({
    filters: [{ name: "XiaoMultiSense" }],
    optionalServices: [
     "6fbe1da7-0000-44de-92c4-bb6e04fb0212", // Live Data Service UUID
     "4fafc201-1fb5-459e-8fcc-c5c9c331914b", // Activity Service UUID
    ],
   });

   msg("connecting to device ...");
   device.addEventListener("gattserverdisconnected", onDisconnected);
   const server = await device.gatt.connect();

   msg("getting primary service ...");
   const service = await server.getPrimaryService(SERVICE_UUID);

   for (const sensor of sensors) {
    msg("characteristic " + sensor + "...");
    BLEsense[sensor].characteristic = await service.getCharacteristic(
     BLEsense[sensor].uuid
    );
    if (BLEsense[sensor].properties.includes("BLENotify")) {
     BLEsense[sensor].characteristic.addEventListener(
      "characteristicvaluechanged",
      function (event) {
       handleIncoming(BLEsense[sensor], event.target.value);
      }
     );
     await BLEsense[sensor].characteristic.startNotifications();
    }
    if (BLEsense[sensor].properties.includes("BLERead")) {
     BLEsense[sensor].polling = setInterval(function () {
      BLEsense[sensor].characteristic.readValue().then(function (data) {
       handleIncoming(BLEsense[sensor], data);
      });
     }, 500);
    }

    BLEsense[sensor].rendered = false;
   }
   bigButton.style.backgroundColor = "green";
   msg("connected.");
  }

  function handleIncoming(sensor, dataReceived) {
   const columns = Object.keys(sensor.data);
   const typeMap = {
    Uint8: { fn: DataView.prototype.getUint8, bytes: 1 },
    Uint16: { fn: DataView.prototype.getUint16, bytes: 2 },
    Float32: { fn: DataView.prototype.getFloat32, bytes: 4 },
   };
   var packetPointer = 0,
    i = 0;

   sensor.structure.forEach(function (dataType) {
    var dataViewFn = typeMap[dataType].fn.bind(dataReceived);
    var unpackedValue = dataViewFn(packetPointer, true);
    sensor.data[columns[i]].push(unpackedValue);
    if (sensor.data[columns[i]].length > maxRecords) {
     sensor.data[columns[i]].shift();
    }
    packetPointer += typeMap[dataType].bytes;
    bytesReceived += typeMap[dataType].bytes;
    i++;
   });
   sensor.rendered = false;
  }

  function onDisconnected(event) {
   let device = event.target;
   bigButton.style.backgroundColor = "red";
   for (const sensor of sensors) {
    if (typeof BLEsense[sensor].polling !== "undefined") {
     clearInterval(BLEsense[sensor].polling);
    }
   }
   const colorPickerElement = document.getElementById("color-picker-container");
   if (colorPickerElement && colorPickerElement.firstChild) {
      colorPickerElement.removeChild(colorPickerElement.firstChild);
   }
   msg("Device " + device.name + " is disconnected.");
  }

  function BLEwriteTo(sensor) {
   if (BLEsense[sensor].writeBusy) return;
   BLEsense[sensor].writeBusy = true;
   BLEsense[sensor].characteristic
    .writeValue(BLEsense[sensor].writeValue)
    .then((_) => {
     BLEsense[sensor].writeBusy = false;
    })
    .catch((error) => {
     console.log(error);
    });
  }

  function startTimer() {
   tens++;
   if (tens <= 9) appendTens.innerHTML = "0" + tens;
   if (tens > 9) appendTens.innerHTML = tens;
   if (tens > 99) {
    seconds++;
    appendSeconds.innerHTML = "0" + seconds;
    tens = 0;
    appendTens.innerHTML = "0" + 0;
   }
   if (seconds > 9) appendSeconds.innerHTML = seconds;
  }
 </script>
 <script>
  // Graphing
  const colors = [
   "#FF355E", "#FD5B20", "#FF6037", "#FF9966", "#FF9933", "#FFCC33",
   "#FFFF66", "#FFFF66",
  ];
  var colorIndex = 0;
  function initGraph(sensor) {
   var title = sensor;
   var series = Object.keys(BLEsense[sensor].data);
   var format = [];
   series.forEach(function (item) {
    colorIndex++;
    if (colorIndex >= colors.length) colorIndex = 0;
    format.push({
     y: [], name: item, mode: "lines", width: 1,
     line: { width: 1, color: colors[colorIndex] },
    });
   });

   Plotly.plot(title, format, {
    plot_bgcolor: "#111111", paper_bgcolor: "#111111",
    margin: { l: 8, r: 8, b: 18, t: 18 }, showlegend: true,
    yaxis: { showticklabels: true },
    xaxis: {
     range: [0, maxRecords], showticklabels: false,
     autorange: false, showgrid: true, zeroline: true,
     tickfont: { size: 10 },
    },
   });
  }

  var flag = 0, timestamp_count = 0;
  function graph(sensor) {
   var labels = Object.keys(BLEsense[sensor].data);
   var values = [];
   labels.forEach(function (label) {
    values.push(BLEsense[sensor].data[label]);
   });
   Plotly.restyle(sensor, { y: values });
  }

  function digit(sensor) {
   const value = BLEsense[sensor].data[sensor].latest();
   const div = document.getElementById(sensor + "-value");
   if (!Number.isNaN(value)) {
    div.innerHTML = Math.round(value * 10) / 10;
   }
  }
  var download_flag = 0;

  // UPDATED: start_recording now resets the new gyroscope arrays
  function start_recording() {
   flag = 1;
   record_data = {
    timestamp: [], aX: [], aY: [], aZ: [],
    gX: [], gY: [], gZ: [],
   };
   console.log("Recording started");
   timestamp_count = 0;
   clearInterval(Interval);
   Interval = setInterval(startTimer, 10);
  }

  function stop_recording() {
   flag = 0;
   console.log("Recording stopped");
   console.log(record_data);
   download_flag = 1;
   clearInterval(Interval);
  }

  const download_file = function (data) {
   const blob = new Blob([data], { type: "text/csv" });
   const url = window.URL.createObjectURL(blob);
   const a = document.createElement("a");
   a.setAttribute("href", url);
   a.setAttribute("download", "imu_data.csv");
   a.click();
  };

  // UPDATED: csvmaker now includes gyroscope data
  const csvmaker = function (data) {
   let csvRows = [];
   const headers = Object.keys(data);
   csvRows.push(headers.join(","));

   for (let i = 0; i < data.timestamp.length; i++) {
    let row = [
     data.timestamp[i],
     data.aX[i], data.aY[i], data.aZ[i],
     data.gX[i], data.gY[i], data.gZ[i]
    ];
    csvRows.push(row.join(","));
   }
   return csvRows.join("\n");
  };

  function download() {
   if (flag == 0 && download_flag == 1) {
    clearInterval(Interval);
    tens = "00";
    seconds = "00";
    appendTens.innerHTML = tens;
    appendSeconds.innerHTML = seconds;
    const csvdata = csvmaker(record_data);
    download_file(csvdata);
    download_flag = 0; // Reset flag after download
   } else {
    alert("Please stop recording before downloading.");
   }
  }

  function bytes() {
   if (bytesReceived > bytesPrevious) {
    bytesPrevious = bytesReceived;
    msg(bytesReceived + " bytes received");
   }
  }

  // UPDATED: write_to_file now records both accelerometer and gyroscope data
  function write_to_file(sensor) {
   if (flag == 1) {
    // Check if data is available to prevent errors
    if (BLEsense.accelerometer.data.Ax.length > 0 && BLEsense.gyroscope.data.Gx.length > 0) {
        record_data.timestamp.push(timestamp_count);
        // Get the latest value (last element in the array)
        record_data.aX.push(BLEsense.accelerometer.data.Ax[BLEsense.accelerometer.data.Ax.length - 1]);
        record_data.aY.push(BLEsense.accelerometer.data.Ay[BLEsense.accelerometer.data.Ay.length - 1]);
        record_data.aZ.push(BLEsense.accelerometer.data.Az[BLEsense.accelerometer.data.Az.length - 1]);
        record_data.gX.push(BLEsense.gyroscope.data.Gx[BLEsense.gyroscope.data.Gx.length - 1]);
        record_data.gY.push(BLEsense.gyroscope.data.Gy[BLEsense.gyroscope.data.Gy.length - 1]);
        record_data.gZ.push(BLEsense.gyroscope.data.Gz[BLEsense.gyroscope.data.Gz.length - 1]);
        timestamp_count += 1000 / 30; // Assuming ~30Hz update rate for timestamp
    }
   }
  }

  var skip_frame = false;
  function draw() {
   function updateViz(sensor, fns) {
    if (BLEsense[sensor].rendered == false) {
     fns.forEach(function (fn) {
      fn(sensor);
     });
     BLEsense[sensor].rendered = true;
    }
   }
   if (skip_frame == false) {
    updateViz("gyroscope", [graph]);
    updateViz("accelerometer", [graph, write_to_file]);
    skip_frame = true;
   } else {
    skip_frame = false;
   }
   requestAnimationFrame(draw);
  }

  initGraph("accelerometer");
  initGraph("gyroscope");
  requestAnimationFrame(draw);
 </script>
</html>
