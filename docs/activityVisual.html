<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BLE IMU Dashboard (single file)</title>

  <!-- Tailwind for quick styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Plotly (modern explicit version) -->
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  <!-- Vue 3 global -->
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>

  <style>
    body { background:#0b1220; color:#e6eef8; font-family: Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; }
    .card { background: #0f1724; border-radius: 12px; padding: 18px; box-shadow: 0 8px 30px rgba(2,6,23,0.6); }
    .sidebar-card { background: #0b1220; border-radius: 10px; padding: 16px; }
    button.primary { background: linear-gradient(90deg,#2563eb,#7c3aed); color:#fff; padding:8px 14px; border-radius:8px; border:0; }
    button.danger { background:#ef4444; color:#fff; padding:8px 14px; border-radius:8px; border:0; }
    .small-muted { color:#9ca3af; font-size:0.9rem; }
  </style>
</head>
<body>
  <div id="app" class="min-h-screen flex">
    <!-- Sidebar -->
    <aside class="w-72 p-6">
      <div class="sidebar-card">
        <h2 class="text-lg font-semibold mb-4">IMU Controller</h2>

        <div class="space-y-3">
          <button @click="toggleConnection" :class="['w-full', 'rounded-md', 'text-white', bleConnected ? 'bg-red-600 hover:bg-red-700' : 'bg-sky-600 hover:bg-sky-700']">
            {{ bleConnected ? 'Disconnect BLE' : 'Connect BLE' }}
          </button>

          <div class="grid grid-cols-1 gap-2 mt-2">
            <button @click="startRecording" class="w-full bg-green-600 hover:bg-green-700 text-white py-2 rounded-md">Start Recording</button>
            <button @click="stopRecording" class="w-full bg-amber-600 hover:bg-amber-700 text-white py-2 rounded-md">Stop Recording</button>
            <button @click="downloadCSV" class="w-full bg-gray-700 hover:bg-gray-600 text-white py-2 rounded-md">Download CSV</button>
          </div>

          <div class="mt-4 small-muted">
            <div>Stopwatch</div>
            <div class="font-mono mt-2 text-lg">{{ formattedTime }}</div>
          </div>

          <div class="mt-4 small-muted">
            <div>Status: <span :class="bleConnected ? 'text-green-400' : 'text-yellow-300'">{{ bleConnected ? 'Connected' : (connecting ? 'Connecting...' : 'Disconnected') }}</span></div>
          </div>
        </div>
      </div>
    </aside>

    <!-- Main -->
    <main class="flex-1 p-6">
      <h1 class="text-2xl font-semibold mb-4">IMU Live — Accelerometer & Gyroscope</h1>

      <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <section class="card">
          <h3 class="text-lg font-medium mb-2">Accelerometer</h3>
          <div id="accelerometer" style="width:100%;height:360px;"></div>
        </section>

        <section class="card">
          <h3 class="text-lg font-medium mb-2">Gyroscope</h3>
          <div id="gyroscope" style="width:100%;height:360px;"></div>
        </section>
      </div>
    </main>
  </div>

<script>
/*
 Single-file BLE+Plotly+CSV dashboard.

 - Connects to XiaoMultiSense (filters by name).
 - Uses the service and char UUIDs you provided.
 - Updates Plotly efficiently using extendTraces (rolling window MAX_POINTS).
 - Records CSV rows into recordedRows[] while recording is ON.
 - CSV rows are full, valid lines (ISO timestamp + numeric values formatted).
*/

const SERVICE_UUID = '6fbe1da7-0000-44de-92c4-bb6e04fb0212';
const ACCEL_UUID   = '6fbe1da7-3001-44de-92c4-bb6e04fb0212';
const GYRO_UUID    = '6fbe1da7-3002-44de-92c4-bb6e04fb0212';

const { createApp } = Vue;

createApp({
  data() {
    return {
      // BLE state
      bleConnected: false,
      connecting: false,
      device: null,
      server: null,
      accelChar: null,
      gyroChar: null,
      // bound event handlers (store function refs so we can remove)
      _onAccel: null,
      _onGyro: null,

      // plotting
      MAX_POINTS: 64,

      // recording
      recording: false,
      recordedRows: [],

      // latest samples (used to make combined CSV rows)
      latestAccel: null,
      latestGyro: null,

      // stopwatch
      stopwatchStart: 0,
      stopwatchMs: 0,
      stopwatchTimer: null
    };
  },

  computed: {
    formattedTime() {
      const ms = this.stopwatchMs % 1000;
      const totalSeconds = Math.floor(this.stopwatchMs / 1000);
      const s = totalSeconds % 60;
      const m = Math.floor(totalSeconds / 60);
      return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${String(Math.floor(ms/10)).padStart(2,'0')}`;
    }
  },

  mounted() {
    // init Plotly charts with three traces each (X,Y,Z)
    const commonLayout = {
      margin: { t: 20, r: 30, l: 60, b: 40 },
      paper_bgcolor: '#0b1220',
      plot_bgcolor: '#0b1220',
      font: { color: '#d1d5db' },
      legend: { orientation: 'h', x: 0.01, y: 1.08 }
    };

    const accelTraces = [
      { x: [], y: [], mode: 'lines', name: 'X', line: { color: '#ff6384', width: 2 } },
      { x: [], y: [], mode: 'lines', name: 'Y', line: { color: '#36a2eb', width: 2 } },
      { x: [], y: [], mode: 'lines', name: 'Z', line: { color: '#4bc0c0', width: 2 } },
    ];

    const gyroTraces = [
      { x: [], y: [], mode: 'lines', name: 'X', line: { color: '#ffa600', width: 2 } },
      { x: [], y: [], mode: 'lines', name: 'Y', line: { color: '#7d3cff', width: 2 } },
      { x: [], y: [], mode: 'lines', name: 'Z', line: { color: '#00a86b', width: 2 } },
    ];

    Plotly.newPlot('accelerometer', accelTraces, Object.assign({}, commonLayout, {
      yaxis: { title: 'Acceleration' },
      xaxis: { type: 'date', tickformat: '%H:%M:%S' }
    }), { responsive: true, displayModeBar: false });

    Plotly.newPlot('gyroscope', gyroTraces, Object.assign({}, commonLayout, {
      yaxis: { title: 'Gyro (°/s)' },
      xaxis: { type: 'date', tickformat: '%H:%M:%S' }
    }), { responsive: true, displayModeBar: false });
  },

  methods: {
    // Toggle connection
    async toggleConnection() {
      if (this.bleConnected) {
        await this.disconnectBLE();
      } else {
        await this.connectBLE();
      }
    },

    // Connect: request device, connect, start notifications
    async connectBLE() {
      if (!navigator.bluetooth) {
        alert('Web Bluetooth not supported. Use Chrome/Edge on desktop or Android.');
        return;
      }

      try {
        this.connecting = true;
        this.device = await navigator.bluetooth.requestDevice({
          filters: [{ name: 'XiaoMultiSense' }],
          optionalServices: [SERVICE_UUID]
        });

        this.device.addEventListener('gattserverdisconnected', () => {
          this._cleanupAfterDisconnect();
        });

        this.server = await this.device.gatt.connect();

        const service = await this.server.getPrimaryService(SERVICE_UUID);

        this.accelChar = await service.getCharacteristic(ACCEL_UUID);
        this.gyroChar  = await service.getCharacteristic(GYRO_UUID);

        // store bound handlers so we can remove them later
        this._onAccel = (e) => this.handleAccel(e);
        this._onGyro  = (e) => this.handleGyro(e);

        await this.accelChar.startNotifications();
        this.accelChar.addEventListener('characteristicvaluechanged', this._onAccel);

        await this.gyroChar.startNotifications();
        this.gyroChar.addEventListener('characteristicvaluechanged', this._onGyro);

        this.bleConnected = true;
      } catch (err) {
        console.error('connectBLE error', err);
        alert('Connection failed: ' + (err && err.message ? err.message : err));
        this._cleanupAfterDisconnect();
      } finally {
        this.connecting = false;
      }
    },

    // Disconnect cleanly and remove listeners
    async disconnectBLE() {
      try {
        if (this.accelChar) {
          try { await this.accelChar.stopNotifications(); } catch(e) {}
          if (this._onAccel) this.accelChar.removeEventListener('characteristicvaluechanged', this._onAccel);
          this._onAccel = null;
        }
        if (this.gyroChar) {
          try { await this.gyroChar.stopNotifications(); } catch(e) {}
          if (this._onGyro) this.gyroChar.removeEventListener('characteristicvaluechanged', this._onGyro);
          this._onGyro = null;
        }
        if (this.device && this.device.gatt && this.device.gatt.connected) {
          this.device.gatt.disconnect();
        }
      } catch (err) {
        console.warn('disconnect error', err);
      }
      this._cleanupAfterDisconnect();
    },

    _cleanupAfterDisconnect() {
      this.bleConnected = false;
      this.device = null;
      this.server = null;
      this.accelChar = null;
      this.gyroChar = null;
      this._onAccel = null;
      this._onGyro = null;
    },

    // push a point onto each trace efficiently (Plotly handles rolling window)
    _extendAccel(ax, ay, az) {
      const t = new Date();
      Plotly.extendTraces('accelerometer', {
        x: [[t],[t],[t]],
        y: [[ax],[ay],[az]]
      }, [0,1,2], this.MAX_POINTS);
    },

    _extendGyro(gx, gy, gz) {
      const t = new Date();
      Plotly.extendTraces('gyroscope', {
        x: [[t],[t],[t]],
        y: [[gx],[gy],[gz]]
      }, [0,1,2], this.MAX_POINTS);
    },

    // --- notification handlers ---

    handleAccel(event) {
      try {
        const dv = event.target.value;
        const ax = dv.getFloat32(0, true);
        const ay = dv.getFloat32(4, true);
        const az = dv.getFloat32(8, true);

        // store latest samples to combine with gyro rows for CSV
        this.latestAccel = { time: new Date(), ax, ay, az };

        // plot
        this._extendAccel(ax, ay, az);

        // record CSV row if recording ON,
        // include latest gyro values if available, otherwise empty strings
        if (this.recording) {
          const row = {
            time: this.latestAccel.time.toISOString(),
            ax: ax.toFixed(6),
            ay: ay.toFixed(6),
            az: az.toFixed(6),
            gx: (this.latestGyro && this.latestGyro.gx != null) ? this.latestGyro.gx.toFixed(6) : '',
            gy: (this.latestGyro && this.latestGyro.gy != null) ? this.latestGyro.gy.toFixed(6) : '',
            gz: (this.latestGyro && this.latestGyro.gz != null) ? this.latestGyro.gz.toFixed(6) : ''
          };
          this.recordedRows.push(row);
        }
      } catch (err) {
        console.error('handleAccel parse error', err);
      }
    },

    handleGyro(event) {
      try {
        const dv = event.target.value;
        const gx = dv.getFloat32(0, true);
        const gy = dv.getFloat32(4, true);
        const gz = dv.getFloat32(8, true);

        this.latestGyro = { time: new Date(), gx, gy, gz };

        // plot
        this._extendGyro(gx, gy, gz);

        // record CSV row if recording ON,
        // include latest accel values if available
        if (this.recording) {
          const row = {
            time: this.latestGyro.time.toISOString(),
            ax: (this.latestAccel && this.latestAccel.ax != null) ? this.latestAccel.ax.toFixed(6) : '',
            ay: (this.latestAccel && this.latestAccel.ay != null) ? this.latestAccel.ay.toFixed(6) : '',
            az: (this.latestAccel && this.latestAccel.az != null) ? this.latestAccel.az.toFixed(6) : '',
            gx: gx.toFixed(6),
            gy: gy.toFixed(6),
            gz: gz.toFixed(6)
          };
          this.recordedRows.push(row);
        }
      } catch (err) {
        console.error('handleGyro parse error', err);
      }
    },

    // start/stop recording & stopwatch
    startRecording() {
      this.recordedRows = [];
      this.recording = true;
      this.stopwatchStart = Date.now();
      this.stopwatchMs = 0;
      if (this.stopwatchTimer) clearInterval(this.stopwatchTimer);
      this.stopwatchTimer = setInterval(() => {
        this.stopwatchMs = Date.now() - this.stopwatchStart;
      }, 50);
    },

    stopRecording() {
      this.recording = false;
      if (this.stopwatchTimer) { clearInterval(this.stopwatchTimer); this.stopwatchTimer = null; }
    },

    // CSV download — builds a clean CSV and includes UTF-8 BOM for Excel compatibility
    downloadCSV() {
      if (!this.recordedRows || this.recordedRows.length === 0) {
        alert('No recorded rows available. Start recording first.');
        return;
      }

      const header = ['time','ax','ay','az','gx','gy','gz'];
      const lines = [header.join(',')];

      for (const r of this.recordedRows) {
        // ensure each field is safe (no newline), numeric fields are strings or empty
        const fields = [
          r.time,
          r.ax === '' ? '' : r.ax,
          r.ay === '' ? '' : r.ay,
          r.az === '' ? '' : r.az,
          r.gx === '' ? '' : r.gx,
          r.gy === '' ? '' : r.gy,
          r.gz === '' ? '' : r.gz
        ];
        lines.push(fields.join(','));
      }

      const csv = lines.join('\r\n'); // CRLF for Excel compatibility
      // add BOM so Excel opens UTF-8 correctly
      const blob = new Blob(['\uFEFF', csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'imu_record.csv';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }
  }
}).mount('#app');
</script>
</body>
</html>
